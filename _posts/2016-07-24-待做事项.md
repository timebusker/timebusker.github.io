---
layout:     post
title:      待做事项
date:       2019-12-31
author:     timebusker
header-img: img/home-bg.jpg
header-img: img/taylorswift/post-bg-swift.jpg
catalog: true
tags:
    - 待做事项
---  

- Tomcat类加载
- 前端RequireJS模块加载
- 前端 Vue、Element-UI


## 面试准备

### 软件开发

#### 后端

##### java基础

- 封装与构造函数：

函数是最基本的封装体，类也是封装体。封装的意义就是属性私有化，提供接口给外部访问，实现对属性的控制功能。

在未申明类构造函数时，没有默认自带参数为空的构造函数（声明后以声明构造函数为准）。

子类只继承父类的默认(缺省)构造函数，即无形参构造函数。如果父类没有默认构造函数，那子类不能从父类继承到任何构造函数。
在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。
如果子类想调用父类的非默认构造函数，则必须使用super来实现。

`super`的使用与`this`有点像，但`super`和`this`是不同的，`this`引用一个对象，
是实实在在存在的，可以作为函数参数，可以作为返回值， 但`super`只是一个关键字，
不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。

`this.字段`：如果出现在父类代码中，指的就是父类属性。 
`this.字段`：如果出现在子类代码中，指的就是子类属性。
`this.方法`：不管出现在父类还是子类代码中，指的都是子类方法。 

- java内存模型

![image](/img/java-coding/2/1.png)   

`Java虚拟机栈：`线程私有，是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，存储局部变量表、操作栈、动态链接、方法出口等信息。
		每个线程都有自己独立的栈空间
		线程栈只存基本类型和对象地址
		方法中局部变量在线程空间中

`Java堆：`所有线程共享的一块内存区域，存放对象实例， 几乎所有的对象实例都在这里分配内存。

`方法区：`线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 对象内存模型

![image](/img/java-coding/2/25.png)

- 类的初始化-变量的初始化

`Java常量`,   `final`修饰,值被设定后不能再被修改

`静态变量`,  `static`修饰,顾名思义，无须创建对象，便可在内存中申请一个存储空间进行存储，存储在`方法区`。

`成员变量`,  也称`实例变量`，它随着当前对象的建立而建立，随着对象的销毁而销毁，存在于对象所在的`堆内存`中

`构造器`，创建class对象时执行

`静态初始化块`,执行`优先级高于非静态的初始化块`，它会`在对象装载到jvm的时候执行一次`，执行完成便销毁，只能初始化`static`修饰的变量

`非静态初始化块`，执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，`在每个对象生成时都会被执行一次`，它可以初始化类的实例变量。但它`会在构造函数执行之前被执行`。

>  [对象的初始化流程](https://blog.csdn.net/mmd0308/article/details/75453720)
		初始化`父类的静态成员`
		初始化`父类的静态代码块`
		初始化**子类的静态成员**
		初始化**子类的静态代码块**
		初始化`父类的非静态成员`
		初始化`父类的非静态代码块`
		初始化`父类的构造方法`
		初始化**子类的非静态成员**
		初始化**子类的非静态代码块**
		初始化**子类的构造方法**
		
成员变量与局部变量：类中的变量不用初始化 方法中的局部变量必须初始化。对于类的成员变量。不管程序有没有显示的初始化，Java虚拟机都会先自动给它初始化为默认值。

##### 数据库基础

##### 算法/逻辑

##### 框架应用

#### 前端

##### Vue

##### Element-UI

##### RequireJS


### 大数据开发

#### hadoop

#### hive

#### spark

#### mpp

#### hbase

#### Phoenix

#### kafka

#### flume

#### zookeeper



