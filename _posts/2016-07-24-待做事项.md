---
layout:     post
title:      待做事项
date:       2019-12-31
author:     timebusker
header-img: img/home-bg.jpg
header-img: img/taylorswift/post-bg-swift.jpg
catalog: true
tags:
    - 待做事项
---  

- Tomcat类加载
- 前端RequireJS模块加载
- 前端 Vue、Element-UI


## 面试准备

### 软件开发

#### 后端

##### java基础

- 面向对象和面向过程
	面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；

	面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
	
	面向过程：优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
				缺点：没有面向对象易维护、易复用、易扩展
	
	面向对象：优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
				缺点：性能比面向过程低

- 封装与构造函数：

函数是最基本的封装体，类也是封装体。封装的意义就是属性私有化，提供接口给外部访问，实现对属性的控制功能。

在未申明类构造函数时，没有默认自带参数为空的构造函数（声明后以声明构造函数为准）。

子类只继承父类的默认(缺省)构造函数，即无形参构造函数。如果父类没有默认构造函数，那子类不能从父类继承到任何构造函数。
在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。
如果子类想调用父类的非默认构造函数，则必须使用super来实现。

`super`的使用与`this`有点像，但`super`和`this`是不同的，`this`引用一个对象，
是实实在在存在的，可以作为函数参数，可以作为返回值， 但`super`只是一个关键字，
不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。

`this.字段`：如果出现在父类代码中，指的就是父类属性。 
`this.字段`：如果出现在子类代码中，指的就是子类属性。
`this.方法`：不管出现在父类还是子类代码中，指的都是子类方法。 

- java内存模型

![image](/img/java-coding/2/1.png)   

`Java虚拟机栈：`线程私有，是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧，存储局部变量表、操作栈、动态链接、方法出口等信息。
		每个线程都有自己独立的栈空间
		线程栈只存基本类型和对象地址
		方法中局部变量在线程空间中

`Java堆：`所有线程共享的一块内存区域，存放对象实例， 几乎所有的对象实例都在这里分配内存。

`方法区：`线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

`JDK8以后，取消了“永久代”，取而代之的是“元空间”，永久代中的数据也进行了迁移，**静态成员变量迁移到了堆中**，方法区是JVM的规范，永久代是方法区的具体实现`

- 对象内存模型

![image](/img/java-coding/2/25.png)

- 类的初始化-变量的初始化

`Java常量`,   `final`修饰,值被设定后不能再被修改

`静态变量`,  `static`修饰,顾名思义，无须创建对象，便可在内存中申请一个存储空间进行存储，存储在`方法区（JDK6）`。

`成员变量`,  也称`实例变量`，它随着当前对象的建立而建立，随着对象的销毁而销毁，存在于对象所在的`堆内存`中

`构造器`，创建class对象时执行

`静态初始化块`,执行`优先级高于非静态的初始化块`，它会`在对象装载到jvm的时候执行一次`，执行完成便销毁，只能初始化`static`修饰的变量

`非静态初始化块`，执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，`在每个对象生成时都会被执行一次`，它可以初始化类的实例变量。但它`会在构造函数执行之前被执行`。

>  [对象的初始化流程](https://blog.csdn.net/mmd0308/article/details/75453720)

		初始化`父类的静态成员`
		
		初始化`父类的静态代码块`
		
		初始化**子类的静态成员**
		
		初始化**子类的静态代码块**
		
		初始化`父类的非静态成员`
		
		初始化`父类的非静态代码块`
		
		初始化`父类的构造方法`
		
		初始化**子类的非静态成员**
		
		初始化**子类的非静态代码块**
		
		初始化**子类的构造方法**
		
成员变量与局部变量：类中的变量不用初始化 方法中的局部变量必须初始化。对于类的成员变量。不管程序有没有显示的初始化，Java虚拟机都会先自动给它初始化为默认值。

- 普通类、接口、抽象类的区别：
	+ 普通类可实例化,接口只能被子类实现再实例化,抽象类只能被子类继承并实现所有抽象方法后能实例化。
	+ 普通类只能实现方法，接口只能做方法的声明,抽象类可以做方法的声明和方法的实现。
	+ 接口中方法或变量没有写 `public static final` 或 `public abstract`会自动补齐。
	+ 抽象方法要被实现，所以不能是静态的，也不能是私有的。
	+ 抽象类里的抽象方法必须全部被子类所实现,如果子类不能全部实现父类的抽象方法,那么该子类只能是抽象类。

- 









##### 数据库基础

##### 算法/逻辑

##### 框架应用

#### 前端

##### Vue

##### Element-UI

##### RequireJS


### 大数据开发

#### hadoop

#### hive

#### spark

#### mpp

#### hbase

#### Phoenix

#### kafka

#### flume

#### zookeeper



