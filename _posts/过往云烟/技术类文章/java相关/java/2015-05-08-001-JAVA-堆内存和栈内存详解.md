---
layout:     post
title:      JAVA-堆内存和栈内存详解
date:       2015-05-08
author:     timebusker
header-img: img/home-bg.jpg
catalog: true
tags:
    - JAVA
---

> JAVA-堆内存和栈内存详解:栈内存随着线程生命周期结束就被清理，堆内存通过GC垃圾回收机制清理。  

![image](img/older/java-coding/2/2.png) 

### java简单内存模型  
Java把内存分成两种，一种叫做**栈内存**，一种叫做**堆内存**。    

在函数中定义的一些[**基本类型的变量和对象的引用变量**]()都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，
java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。    

堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。
在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，
在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，
引用变量相当于为数组或者对象起的一个别名，或者代号。引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。
而数组或者对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，
数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，
但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，
栈中的变量指向堆内存中的变量，这就是 Java 中的指针。   

### JVM中的堆和栈 
JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈。也就是说，对于一个Java程序来说，
它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态，JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。 

我们知道，某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。
当线程激活一个Java方法，JVM就会在线程的Java堆栈里新压入一个帧。这个帧自然成为了当前帧。
在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。
这个帧在这里和编译原理中的活动纪录的概念是差不多的。

从Java的这种分配机制来看,堆栈又可以这样理解为堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)
为这个线程建立的存储区域，该区域具有先进后出的特性。 

每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，
并由应用所有的线程共享。跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，
但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，
而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。栈中的这个变量就成了数组或对象的引用变量。 

Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，
它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，
因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，
缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。 

**栈有一个很重要的特殊性**，就是存在栈中的数据可以共享。假设我们同时定义：   
```java 
int a = 3; 
int b = 3; 
```  
编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，
如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，
因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，
如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;
如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

### java内存分配策略  
按照编译原理的观点,程序运行时的内存分配有三种策略，分别是静态的、栈式的、和堆式的。   

##### 静态存储分配
静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间，
这种分配策略要求程序代码中不允许有可变数据结构(比如数组)的存在，也不允许有嵌套或者递归的结构出现,
因为它们都会导致编译程序无法计算准确的存储空间需求。

##### 栈式存储分配  
栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的，
和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，
只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，
必须知道该程序模块所需的数据区大小才能够为其分配内存，和我们在数据结构所熟知的栈一样，
栈式存储分配按照先进后出的原则进行分配。 

##### 堆式存储分配  
堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，
比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放.。

### 堆和栈的比较   
从堆和栈的功能和作用来通俗的比较，堆主要用来存放对象的，栈主要是用来执行程序的。而这种不同又主要是由于堆和栈的特点决定的。   

在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的，所有的局部变量，形式参数都是从栈中分配内存空间的。
实际上也不是什么分配，只是从栈顶向上用就行，就好像工厂中的传送带(conveyor belt)一样，
Stack Pointer会自动指引你到放东西的位置，你所要做的只是把东西放下来就行，退出函数的时候，修改栈指针就可以把栈中的内容销毁，
这样的模式速度最快， 当然要用来运行程序了。需要注意的是，在分配的时候，
比如为一个即将要调用的程序模块分配数据区时，应事先知道这个数据区的大小，也就说是虽然分配是在程序运行时进行的，
但是分配的大小多少是确定的，不变的，而这个"大小多少"是在编译时确定的,不是在运行时。     

堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配，所以在分配和销毁时都要占用时间，
因此用堆的效率非常低。但是堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。
因此，用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性，堆内存分配是必不可少的，
因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。在C++中，要求创建一个对象时，
只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，
必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间。这也正是导致我们刚才所说的效率低的原因。