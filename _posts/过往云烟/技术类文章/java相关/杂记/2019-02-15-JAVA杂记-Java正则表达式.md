---
layout:     post
title:      Java正则表达式
date:       2019-07-15
author:     timebusker
header-img: img/home-bg.jpg
catalog: true
tags:
    - JAVA杂记
---

#### Java正则表达式基础

- 字符

![字符](img/older/java-coding/杂记/1.png) 



- 分枝条件

用`|`把不同的规则分别表达。

如：`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配`两种`以连字号分隔的电话号码：一种是`三位区号`，8位本地号(如010-12345678)，一种是`4位区号`，7位本地号(0376-2233445)。

- 分组

重复单个字符直接在字符后面加上限定符就行了，但如果想要重复多个字符又该怎么办？你可以用`小括号来指定子表达式`(也叫做`分组`)，
然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式`进行其它一些操作`。

使用小括号指定一个子表达式后，`匹配这个子表达式的文本`(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。
`捕获组`可以通过`从左到右计算其开括号来编号`。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组：

             ((A)(B(C)))
             (A)
             (B(C))
             (C)
> `组零始终代表整个表达式`:

之所以这样命名捕获组是因为在匹配中，保存了与这些组匹配的输入序列的每个子序列。捕获的子序列稍后可以通过 Back 引用在表达式中使用，也可以在匹配操作完成后从匹配器获取。

与组关联的捕获输入始终是与组最近匹配的子序列。如果由于量化的缘故再次计算了组，则在第二次计算失败时将保留其以前捕获的值（如果有的话）。
例如，将字符串 "aba" 与表达式 (a(b)?)+ 相匹配，会将第二组设置为 "b"。在每个匹配的开头，所有捕获的输入都会被丢弃。

以`(?)`开头的组是纯的非捕获 组，它不捕获文本，也不针对组合计进行计数。

后向引用用于重复搜索前面某个分组匹配的文本。例如：`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像`go go`, 或者`kitty kitty`。
也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+))`,这样就把`\w+`的组名指定为`Word`了。
要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。

- 零宽断言

`(?=exp)`也叫零宽度正预测先行断言，它断言被匹配的字符串以表达式exp结尾但除了结尾以外的部分。比如`\b\w+(?=ing\b)`，
匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。

`(?<=exp)`也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式`exp`。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，
例如在查找reading a book时，它匹配ading。

```
(?=exp)	    匹配exp前面的位置
(?<=exp)	匹配exp后面的位置
(?!exp)	    匹配后面跟的不是exp的位置
(?<!exp)	匹配前面不是exp的位置
```

- 注释

小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d \d?(?#0-199)`。

- 贪婪与懒惰

```
*?	     重复任意次，但尽可能少重复
+?	     重复1次或更多次，但尽可能少重复
??	     重复0次或1次，但尽可能少重复
{n,m}?	 重复n到m次，但尽可能少重复
{n,}?	 重复n次以上，但尽可能少重复
```

#### Java基本用法

```
// "\\ba\\w*\\b"    匹配以字母a为开头的单词
// 将给定的正则表达式编译到具有给定标志的模式中
Pattern pattern = Pattern.compile("\\ba\\w*\\b");
// 创建匹配给定输入与此模式的匹配器
Matcher matcher = pattern.matcher("abcdab cccabcd aaacd");
int index = 0;
// 查找与该模式匹配的输入序列的下一个子序列
// 方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。
// 如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息
while (matcher.find()) {
    // 返回由以前匹配操作所匹配的输入子序列
    String res = matcher.group();
    System.out.println(index + ":" + res);
    index++;
}
```

https://www.cnblogs.com/yw0219/p/8047938.html










